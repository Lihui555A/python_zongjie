import pandas as pd
import numpy as np
#生成一维数组
#s=pd.Series([1,3,5,np.nan,5,8])#np.nan表示啥也没有
#print(s) #结果：
'''
0    1.0
1    3.0
2    5.0
3    NaN
4    5.0
5    8.0
dtype: float64'''

#生成二维数组     其实对于pandas来说里边所有的元素都是列表，模型是这样的Dataframe([[第一行数据],[第二行数据],[第三行数据]],columns=['','',''],index=['','','']),数据这一块放的是二维的，也就是矩阵形式的
#dates=pd.date_range(start='20130102',end='20130130')
#print(dates) #结果：这个玩意貌似就是帮忙生成时间标签的，括号里输入起始和结束时间
'''DatetimeIndex(['2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05',
               '2013-01-06', '2013-01-07', '2013-01-08', '2013-01-09',
               '2013-01-10', '2013-01-11', '2013-01-12', '2013-01-13',
               '2013-01-14', '2013-01-15', '2013-01-16', '2013-01-17',
               '2013-01-18', '2013-01-19', '2013-01-20', '2013-01-21',
               '2013-01-22', '2013-01-23', '2013-01-24', '2013-01-25',
               '2013-01-26', '2013-01-27', '2013-01-28', '2013-01-29',
               '2013-01-30'],
              dtype='datetime64[ns]', freq='D')'''
#dates=pd.date_range(start='20130102',periods=10)
#print(dates) #结果：
'''DatetimeIndex(['2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05',
               '2013-01-06', '2013-01-07', '2013-01-08', '2013-01-09',
               '2013-01-10', '2013-01-11'],
              dtype='datetime64[ns]', freq='D')'''
#dates=pd.date_range(start='20130102',end='20131231',freq='M')
#print(dates) #结果：
'''DatetimeIndex(['2013-01-31', '2013-02-28', '2013-03-31', '2013-04-30',
               '2013-05-31', '2013-06-30', '2013-07-31', '2013-08-31',
               '2013-09-30', '2013-10-31', '2013-11-30', '2013-12-31'],
              dtype='datetime64[ns]', freq='M')'''

#df=pd.DataFrame(np.random.randn(12,4),index=dates,columns=list('ABCD'))#也就是说列的名称得是列表里的字符串
#print(list('ABCD'))#结果：['A', 'B', 'C', 'D']
#print(df)  #结果：
'''   
                A         B         C         D
2013-01-31  0.512860 -1.209592 -1.385400 -1.046744
2013-02-28 -1.517573  1.724661  0.127063  0.536654
2013-03-31  0.848855 -0.377906 -1.365316 -0.351349
2013-04-30 -1.247512  0.878739 -1.372404 -0.588999
2013-05-31 -0.757434 -0.181250  0.413289 -0.386572
2013-06-30  0.984032  0.734828  0.598135 -1.085291
2013-07-31 -0.588128 -1.316583 -0.441422  1.439916
2013-08-31  0.123344  0.848669  0.635996 -2.920740
2013-09-30 -0.529431 -0.662856  0.307002 -0.682047
2013-10-31 -0.894530  1.379271 -0.344365  0.747481
2013-11-30 -0.717500 -1.197560  0.345371 -0.070436
2013-12-31 -1.146465  0.680244  0.397743  1.892901
'''

#df=pd.DataFrame([[np.random.randint(1,100)for j in range(4)]for i in range(12)],index=dates,columns=['a','b','c','d'])
#print(df)#结果
''' 
            a   b   c   d
2013-01-31  10  12  67  61
2013-02-28  85  93  24  96
2013-03-31  14  40   2  17
2013-04-30  82  22  71  77
2013-05-31  89  70  24  76
2013-06-30  41  51  70  54
2013-07-31  93  66  56  86
2013-08-31  27  55  22  77
2013-09-30  49  57  41  29
2013-10-31  48  42  10   7
2013-11-30   1  94  79  69
2013-12-31  25  33  12  80
'''
#df=pd.DataFrame(np.random.randint(10,100,100).reshape(10,10),index=['一','二','三','四','五','六','七','八','九','十'],columns=['A','B','C','D','E','F','G','H','I','J'])
#print(df)  #结果：
'''
    A   B   C   D   E   F   G   H   I   J
一  64  89  87  85  16  62  27  96  21  84
二  57  20  15  28  75  49  86  86  84  45
三  74  76  21  28  98  32  50  71  98  25
四  63  10  93  44  17  49  92  71  74  70
五  15  64  32  59  95  29  96  19  28  56
六  98  29  15  10  79  59  68  70  64  33
七  43  45  17  53  79  46  78  76  87  63
八  44  46  82  22  47  90  49  68  78  66
九  35  60  14  33  12  19  73  64  97  28
十  80  84  27  61  70  61  72  35  70  54
'''


#df=pd.DataFrame(np.random.randint(10,100,100).reshape(10,10))#如果不规定列名和行名，则自动产生
#print(df) #结果：
'''
    0   1   2   3   4   5   6   7   8   9
0  87  39  95  30  74  56  96  13  70  59
1  99  71  50  61  17  11  70  78  17  90
2  25  22  59  38  33  12  53  22  21  30
3  39  40  64  34  98  80  97  12  41  21
4  92  20  69  89  76  83  84  29  36  40
5  94  62  97  30  69  71  10  63  78  33
6  53  72  24  15  20  77  62  60  20  52
7  44  99  23  12  77  81  11  51  63  19
8  36  50  53  71  73  54  65  50  98  59
9  35  86  51  12  60  77  82  99  73  43
'''
#总结一下。
#对于series，和DataFrame来说，里面要的主要数据其实都是列表，对于DataFrame来说可以放np产生的矩阵，对于series可以放np产生的一维向量
#而pd.date_range()这是个函数，用来产生一些时间的一个大列表，可以用来当做列名或者行名



#另外一种产df方式
#df=pd.DataFrame({'A':[np.random.randint(1,100)for  i in range(4)],               #有了列名，每个列名后要放一维的数据，也就是一个列表
   #              'B':pd.date_range(start='20130101',periods=4,freq='D'),  #这个玩意产生的也是个列表
    #             'C':pd.Series([1,2,3,4],index=list(range(4)),dtype='float32'),#这里的index要改成跟大矩阵一样的行名
     #            'D':np.array([3]*4,dtype='int32'),         #这个玩意就代替了一行列表，为啥呢因为在series中我们不是需要列表吗，但是也可以用np产生的向量
      #           'E':pd.Categorical(['TESR','TRAIN','TESR','TRAIN']),
       #          'F':'FOO'} )
#print(np.array([3]*4))#结果：[3 3 3 3]
#print([3]*4) #结果：[3, 3, 3, 3]
#print(df) #结果：
'''
    A          B    C  D      E    F
0  37 2013-01-01  1.0  3   TESR  FOO
1  10 2013-01-02  2.0  3  TRAIN  FOO
2  89 2013-01-03  3.0  3   TESR  FOO
3  27 2013-01-04  4.0  3  TRAIN  FOO

'''

#其他产生df的方式
#df=pd.DataFrame({'A':[np.random.randint(1,10)for i in range(4)],
   #              'B':pd.Series([1,2,3,4],index=['zhou','li','wang','zheng']),
    #             'C':np.array([3]*4),
     #            'D':pd.Categorical(['REST','FDFD','DFSF','SDFSF']),
      #           'E':'DLL'})
#print(df)
#结果：这个好的地方在哪呢，就是在弄pd.Series的时候里边弄上了index也就是说规定了行名
'''
       A  B  C      D    E
zhou   1  1  3   REST  DLL
li     2  2  3   FDFD  DLL
wang   7  3  3   DFSF  DLL
zheng  4  4  3  SDFSF  DLL
'''

#还有一种产生df的方式，但是这个方式我们只规定产生列名，行名自动产生,每个列名后面对应的是自己这个列里的内容
#df=pd.DataFrame({'A':[np.random.randint(1,5)for i in range(8)],
#                 'B':[np.random.randint(10,15)for i in range(8)],
#                 'C':[np.random.randint(20,30)for i in range(8)],
#                 'D':[np.random.randint(40,50)for i in range(8)]})
#print(df)  #结果：
'''
   A   B   C   D
0  3  11  20  45
1  3  13  22  48
2  1  11  22  47
3  4  10  21  41
4  2  14  20  41
5  1  11  26  41
6  4  14  25  49
7  3  11  27  46
'''

#二维数组的查看

df=pd.DataFrame(np.random.randint(10,100,100).reshape(10,10),index=['一','二','三','四','五','六','七','八','九','十'],columns=['A','B','C','D','E','F','G','H','I','J'])
print(df)  #结果：
'''
    A   B   C   D   E   F   G   H   I   J
一  64  89  87  85  16  62  27  96  21  84
二  57  20  15  28  75  49  86  86  84  45
三  74  76  21  28  98  32  50  71  98  25
四  63  10  93  44  17  49  92  71  74  70
五  15  64  32  59  95  29  96  19  28  56
六  98  29  15  10  79  59  68  70  64  33
七  43  45  17  53  79  46  78  76  87  63
八  44  46  82  22  47  90  49  68  78  66
九  35  60  14  33  12  19  73  64  97  28
十  80  84  27  61  70  61  72  35  70  54
'''
#print(df.head()) #结果是默认显示全部内容的前五行,括号里的数字表示想要表示的行数
'''
    A   B   C   D   E   F   G   H   I   J
一  46  42  81  55  49  77  58  22  89  54
二  11  70  72  23  74  81  82  74  73  41
三  18  66  82  90  61  48  25  93  14  49
四  49  19  45  98  13  62  88  42  28  53
五  93  75  21  24  78  15  77  29  77  76
'''
#print(df.tail(3))#表示查看后三行
#print(df.index)  #查看行的名字
# #结果：Index(['一', '二', '三', '四', '五', '六', '七', '八', '九', '十']
#print(df.columns)  #查看列的名字
#结果：Index(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], dtype='object')
#print(df.values) #查看数据
#结果：
'''
[[18 14 56 59 47 23 61 21 57 47]
 [44 85 15 33 75 18 50 75 68 99]
 [62 58 30 30 37 10 65 44 43 69]
 [90 73 77 72 88 19 34 76 43 11]
 [48 68 97 94 79 43 70 46 84 76]
 [26 36 86 23 93 33 33 71 96 16]
 [91 28 39 22 83 84 75 24 10 40]
 [96 26 96 32 99 12 57 62 27 20]
 [67 42 84 74 41 97 57 16 16 82]
 [50 65 33 78 52 16 34 15 49 69]]
'''
#print(df.describe())#这个玩意更牛逼啊，返回的是每一列的元素的个数，平均数，标准差，最小值，和最大值
'''
               A          B          C          D          E          F         G          H          I          J  
count  10.000000  10.000000  10.000000  10.000000  10.000000  10.000000   10.000000  10.000000  10.000000  10.000000  
mean   51.500000  65.100000  49.800000  43.600000  48.400000  55.200000   56.200000  56.700000  65.200000  51.700000  
std    29.949032  26.273985  29.012644  18.798346  25.162582  29.169239    24.330137  25.582329  20.660213  24.376902  
min    11.000000  31.000000  12.000000  17.000000  14.000000  12.000000    23.000000  18.000000  31.000000  20.000000  
25%    21.500000  39.000000  31.750000  35.250000  31.000000  34.000000   38.250000  36.750000  54.750000  33.250000  
50%    64.000000  73.000000  42.500000  37.500000  43.500000  59.500000   57.500000  54.500000  63.500000  49.500000  
75%    76.500000  85.250000  75.750000  49.750000  69.750000  77.250000   79.250000  72.000000  83.250000  65.500000  
max    84.000000  97.000000  96.000000  85.000000  86.000000  97.000000   84.000000  94.000000  92.000000  97.000000  

'''
#print(df.T)  #给个对比的结果：
#没有转置前的                                                       转置后的：就是把原来所有的行变成了列，包括标签
'''
    A   B   C   D   E   F   G   H   I   J                       一   二   三   四   五   六   七   八   九   十
一  47  95  41  83  48  59  70  31  19  11                    A  47  14  91  93  27  61  53  14  74  31
二  14  98  57  60  48  43  58  15  46  49                    B  95  98  12  85  10  51  40  28  47  93
三  91  12  23  73  98  48  20  86  99  57                    C  41  57  23  77  78  78  72  55  90  59
四  93  85  77  29  44  11  75  94  79  18                    D  83  60  73  29  91  35  34  87  99  68 
五  27  10  78  91  66  26  83  42  89  65                    E  48  48  98  44  66  19  70  12  43  91
六  61  51  78  35  19  66  56  61  91  20                    F  59  43  48  11  26  66  46  50  77  36
七  53  40  72  34  70  46  32  60  99  23                    G  70  58  20  75  83  56  32  39  68  28
八  14  28  55  87  12  50  39  60  88  89                    H  31  15  86  94  42  61  60  60  52  87
九  74  47  90  99  43  77  68  52  78  45                    I  19  46  99  79  89  91  99  88  78  17
十  31  93  59  68  91  36  28  87  17  29                    J  11  49  57  18  65  20  23  89  45  29

'''
#print(df.sort_index(axis=0,ascending=False))#把数据按照行名降序排列
#print(df.sort_index(axis=0,ascending=True))#把数据按照行名按照升序排列
#print(df.sort_index(axis=1,ascending=True))#把数据按照列名按照升序排列
#print(df.sort_values(by='A'))#按照某列的大小排序,默认的是按照升序排列
#print(df.sort_values(by='A',ascending=False))#按照某列的降序排序
print(df['A'])#打的具体的某一列
print(df[1:2])
#print(df[0:2])#这里要注意跟numpy的区别,numpy中a[:,2]表示拿出矩阵中第二列所有的东西，这里呢表示拿出这个df的前两行所有的东西
#print(df[2:6])#这里表示打印第二行到六行的数据
#print(df.iloc[1])#这个呢表示拿出具体的某一行，括号里是这一行的下标
#print(df.iloc[0:3,0:4])#查询前三行，前4列的数据
#print(df.iloc[0:3,:])#跟np没啥差别了前三行的所有数据
#print(df.iloc[[0,2,3],[0,4]])#查询指定多行多列数据
#print(df.iloc[0,1])#查询指定行，列位置的数据值
#print(df[df.A>50])#查询A中大于50的所有行
print(df.loc['一'])#也可以用这样方式来拿出具体的某一行

#print(df.loc[:,['A','B']])#打印多列，这个中括号里面呀是有逗号的，逗号前是行，逗号后是列，想选择那些行，那些列，只需要在逗号的前后加上【】，然后把行名和列名写进去就行了，如果只想打多列，就在逗号前写;
#print(df.loc[['一','二'],['A','B']] )#我只想要前两行的前两列就可以这么干了
#print(df.loc[['一'],['A']] )#也可以用这个方法来找具体的某个位置的值
#print(df.at['一','A'])#这个返回的只有具体的位置的值，没有行和列的信息
#比较一下iloc  和 loc 两个表示形式差不多一样，不一样的是一个是写下标，一个是名称


#数据的修改与设置
#df.at[0,2]=3#修改具体某个位置上的值
#df.loc[:,'D']=[1,2,3,4,5,6,7,8,9,10]#修改某个具体列上的值，
#df['D']=-df['D']#是原来元素的负数
#print(df)
#print(df.mean())#结果：这个是计算每列的平均值
'''
A    43.6
B    55.9
C    58.4
D    49.3
E    66.1
F    52.9
G    61.2
H    62.0
I    51.4
J    55.6
dtype: float64
'''
#print(df.mean(1))#结果：这个是计算每行的平均值
'''
dtype: float64
一    65.7
二    48.4
三    63.3
四    59.5
五    56.5
六    44.3
七    50.1
八    52.7
九    59.8
十    38.4
dtype: float64

'''
#print(df['D'].value_counts())#这个是看这一列中的元素在这列中有几个
'''79    1
46    1
75    1
89    1
15    1
68    1
83    1
14    1
'''
#缺失值处理，据说挺重要
#df=pd.DataFrame({'A':[np.random.randint(1,10)for i in range(4)],
    #            'B':pd.Series([1,2,3,4],index=['zhou','li','wang','zheng']),
      #          'C':np.array([3]*4),
       #         'D':pd.Categorical(['REST','FDFD','DFSF','SDFSF']),
        #         'E':'DLL'})
#print(df)

#df1=df.reindex(index=['zhou','li','wang','zheng'],columns=list(df.columns)+['G'])
#print(df1)  #结果：就是添加列。或者说改变列名或者行名，如果是新加的名字那么里边的数值就是空的，原来没变的名字里的数值不变

'''
原图
       A  B  C      D    E
zhou   2  1  3   REST  DLL
li     9  2  3   FDFD  DLL
wang   2  3  3   DFSF  DLL
zheng  5  4  3  SDFSF  DLL
修改后的 
       A  B  C      D    E   G
zhou   2  1  3   REST  DLL NaN
li     9  2  3   FDFD  DLL NaN
wang   2  3  3   DFSF  DLL NaN
zheng  5  4  3  SDFSF  DLL NaN

'''
#print(pd.isnull(df1))#返回那些数值是没有的  结果：
'''
           A      B      C      D      E     G
zhou   False  False  False  False  False  True
li     False  False  False  False  False  True
wang   False  False  False  False  False  True
zheng  False  False  False  False  False  True
'''
#df1.at[0,5]=3#这个是用来改值的，

#print(df1.dropna())#返回不包含空值的行   结果：
'''
      A  B  C     D    E    G
zhou  1  1  3  REST  DLL  3.0
'''
#df1['G'].fillna(5,inplace=True)# 使用指定值填充缺失值
#print(df1)   #结果
'''
       A  B  C      D    E    G
zhou   4  1  3   REST  DLL  3.0
li     1  2  3   FDFD  DLL  5.0
wang   5  3  3   DFSF  DLL  5.0
zheng  5  4  3  SDFSF  DLL  5.0
'''
#df2=pd.DataFrame(np.random.randn(10,4))#产生10行4列的数据
#p1=df2[:2]
#print(df2[:2])#拿出前两行的东西 结果：
'''
          0         1         2         3
0 -1.211026 -1.628830 -0.861065  1.775522
1 -0.259077  2.368849  0.078183  1.363944
'''
#print(df2[3:7])
#p2=df2[3:7]
#结果：
'''
          0         1         2         3
3  0.261039  0.170326  0.945022  1.754448
4 -0.393766  0.590962  0.128393  0.490344
5 -1.831858  0.460551 -1.061429 -1.232045
6 -0.992095 -1.395277  0.724728  0.845961

'''
#df3=pd.concat([p1,p2])
#print(df3)#数据行合并  结果：
'''
          0         1         2         3
0  0.165960  0.358603 -0.826918  0.686803
1 -0.653941  0.604008  0.697806 -0.619765
3  1.032952  0.597687  1.194481  0.455465
4 -0.925990  0.795875 -1.677983 -0.482058
5  1.270940 -0.718117  0.546342  1.352406
6 -1.093653 -0.063410 -0.594861  0.069003
'''
#print(df2==df3)#判断两个二维数据是否相等，返回True 或False
#df4=pd.DataFrame({'a':[np.random.randint(1,5)for i in range(8)],
 #                 'b': [np.random.randint(10, 15) for i in range(8)],
  #                'c': [np.random.randint(20, 30) for i in range(8)],
   #               'd': [np.random.randint(80, 100) for i in range(8)],})
#print(df4)







#print(df4.groupby('a').sum())
#结果;就是从df4中按照a列中有的数据分组，然后求和，比如说本例子，a中有8个数，但是都是1,2,3,4的重复，所以我们就要找是1那些行的后边的每列加起来的数据，以此类推
'''
   a   b   c   d
0  3  14  28  83
1  1  11  21  80
2  3  14  28  90
3  2  11  28  86
4  1  14  25  94
5  4  10  22  86
6  4  14  21  96
7  4  13  21  90
    b   c    d
a             
1  25  46  174
2  11  28   86
3  28  56  173
4  37  64  272


'''


#print(df4.groupby(['a','b']).mean())#这个还是放放吧看不懂啊

